<!doctype html>

<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Birch - 4 Người</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #gameWrap{position:relative;width:100%;height:100vh;background:linear-gradient(#88d8ff,#8ad4a7);display:flex;align-items:center;justify-content:center}
    canvas{background:transparent;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
    .corner-btn{
      position:fixed;z-index:40;width:64px;height:64px;border-radius:10px;border:2px solid rgba(255,255,255,0.85);display:flex;align-items:center;justify-content:center;font-weight:700;user-select:none;background:linear-gradient(180deg,rgba(255,255,255,0.12),rgba(255,255,255,0.04));backdrop-filter:blur(3px);
      box-shadow:0 6px 18px rgba(0,0,0,0.15);
    }
    .tl{left:12px;top:12px}
    .tr{right:12px;top:12px}
    .bl{left:12px;bottom:12px}
    .br{right:12px;bottom:12px}
    .corner-btn:active{transform:translateY(2px)}
    #hud{position:fixed;left:50%;transform:translateX(-50%);top:12px;color:#012;background:rgba(255,255,255,0.9);padding:6px 12px;border-radius:999px;font-weight:700;z-index:50}
    #info{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;color:#012;background:rgba(255,255,255,0.9);padding:6px 12px;border-radius:999px;font-weight:600;z-index:50}
    .small{font-size:12px;opacity:0.9}
    @media (max-width:600px){.corner-btn{width:56px;height:56px}}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c" width="800" height="600"></canvas>
  </div>  <div id="hud">Scores — P1: <span id="s0">0</span> • P2: <span id="s1">0</span> • P3: <span id="s2">0</span> • P4: <span id="s3">0</span></div>  <div id="info" class="small">Chạm/tap nút ở góc để nhảy. Phím: Q (TL), P (TR), A (BL), L (BR). Nhấn R để reset.</div>  <div class="corner-btn tl" id="btn0">Q</div>
  <div class="corner-btn tr" id="btn1">P</div>
  <div class="corner-btn bl" id="btn2">A</div>
  <div class="corner-btn br" id="btn3">L</div>  <script>
    // Flappy 4-player simple implementation
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W = canvas.width, H = canvas.height;

    // Resize canvas to fit viewport while keeping aspect ratio
    function fitCanvas(){
      const wrap = document.getElementById('gameWrap');
      const maxW = Math.min(window.innerWidth - 20, 900);
      const maxH = Math.min(window.innerHeight - 40, 700);
      let ratio = W/H;
      let w = maxW, h = Math.round(w/ratio);
      if(h > maxH){ h = maxH; w = Math.round(h*ratio); }
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    class Bird{
      constructor(x,y,color){
        this.x = x; this.y = y; this.r = 14; this.vy = 0; this.alive = true; this.color = color; this.score = 0;
      }
      flap(){ if(!this.alive) return; this.vy = -6; }
      update(dt){ if(!this.alive) return; this.vy += 0.28; this.y += this.vy; if(this.y + this.r > H) { this.y = H - this.r; this.alive = false } if(this.y - this.r < 0){ this.y = this.r; this.vy = 0 } }
      draw(ctx){ ctx.beginPath(); ctx.fillStyle = this.color; ctx.ellipse(this.x,this.y,this.r*1.2,this.r,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(this.x+6,this.y-4,8,4); }
      reset(y){ this.y = y; this.vy = 0; this.alive = true; this.score = 0 }
    }

    const players = [
      new Bird(120, H*0.25, '#ff4d4f'),
      new Bird(120, H*0.4, '#ffd666'),
      new Bird(120, H*0.6, '#73d13d'),
      new Bird(120, H*0.8, '#40a9ff')
    ];

    // Pipes
    const pipes = [];
    const PIPE_GAP = 150;
    const PIPE_W = 60;
    let pipeTimer = 0;
    let pipeInterval = 1500; // ms

    function spawnPipe(){
      const topH = 60 + Math.random()*(H-260);
      pipes.push({x: W, top: topH, passed: [false,false,false,false]});
    }

    // Input mapping
    const keyMap = { 'q':0, 'p':1, 'a':2, 'l':3 };
    document.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();
      if(k === 'r'){ resetAll(); }
      if(keyMap[k] !== undefined) players[keyMap[k]].flap();
    });

    // Buttons
    for(let i=0;i<4;i++){
      const btn = document.getElementById('btn'+i);
      btn.addEventListener('pointerdown', ()=>{ players[i].flap(); });
      // also prevent ghost click
      btn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); players[i].flap(); }, {passive:false});
    }

    function rectsCollide(rx,ry,rw,rh,cx,cy,cr){
      // circle vs rect
      const nearestX = Math.max(rx, Math.min(cx, rx+rw));
      const nearestY = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - nearestX; const dy = cy - nearestY;
      return (dx*dx + dy*dy) < (cr*cr);
    }

    function update(dt){
      // spawn pipes
      pipeTimer += dt;
      if(pipeTimer > pipeInterval){ spawnPipe(); pipeTimer = 0; }

      // update pipes
      for(let i=pipes.length-1;i>=0;i--){
        pipes[i].x -= 2.6; // speed
        if(pipes[i].x + PIPE_W < -50) pipes.splice(i,1);
      }

      // update players
      players.forEach((p,pi)=>{
        p.update(dt);
        // collisions with pipes
        pipes.forEach(pipe=>{
          if(!p.alive) return;
          const rx = pipe.x, rw = PIPE_W;
          const topH = pipe.top;
          // top rect: x,0,w,topH
          if(rectsCollide(rx,0,rw,topH,p.x,p.y,p.r) || rectsCollide(rx,topH+PIPE_GAP,rw,H-(topH+PIPE_GAP),p.x,p.y,p.r)){
            p.alive = false;
          }
          // scoring when pass
          if(!pipe.passed[pi] && pipe.x + PIPE_W < p.x - p.r){ pipe.passed[pi] = true; p.score += 1; document.getElementById('s'+pi).textContent = p.score; }
        });
      });
    }

    function draw(){
      // background
      ctx.clearRect(0,0,W,H);
      // draw ground
      ctx.fillStyle = '#7f5a3c';
      ctx.fillRect(0,H-40,W,40);
      // draw pipes
      pipes.forEach(pipe=>{
        ctx.fillStyle = '#2b7a2b';
        ctx.fillRect(pipe.x,0,PIPE_W,pipe.top);
        ctx.fillRect(pipe.x,pipe.top+PIPE_GAP,PIPE_W,H-(pipe.top+PIPE_GAP)-40);
        // caps
        ctx.fillStyle = '#1f5a1f';
        ctx.fillRect(pipe.x-6, pipe.top-10, PIPE_W+12, 10);
        ctx.fillRect(pipe.x-6, pipe.top+PIPE_GAP, PIPE_W+12, 10);
      });
      // draw birds
      players.forEach(p=>{ p.draw(ctx); });

      // draw center dividing lines for fun
      ctx.fillStyle='rgba(255,255,255,0.06)';
      for(let i=0;i<4;i++){ ctx.fillRect(0, (H/4)*i, W, 1); }

      // overlay text for each player (alive/dead)
      ctx.font = '13px system-ui'; ctx.textBaseline='top';
      players.forEach((p,i)=>{
        ctx.fillStyle = '#012'; ctx.fillText((p.alive ? 'Alive' : 'Dead') + ' • P' + (i+1) + ' • ' + p.score, 8, 8 + i*18);
      });
    }

    let last = performance.now();
    function loop(now){
      const dt = now - last; last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function resetAll(){
      players[0].reset(H*0.25); players[1].reset(H*0.4); players[2].reset(H*0.6); players[3].reset(H*0.8);
      pipes.length = 0; pipeTimer = 0; players.forEach((p,i)=>document.getElementById('s'+i).textContent = '0');
    }

    // start
    resetAll();
    requestAnimationFrame(loop);
  </script></body>
  </html>
